## 架构演变

### 单体架构

Web应用程序发展的早期，大部分web工程师将所有的功能模块打包到一起并放在一个web容器中运行，所有功能模块使用同一个数据库。

下图是一个单体架构的电商系统：

![20191126182610911](E:\STS+Maven构建SSM项目\20191126182610911.png)

特点：

1、所有的功能集成在一个项目工程中。

2、所有的功能打在一个war包部署到服务器。

3、通过部署应用集群和数据库集群来提高系统的性能。

优点：

1、项目架构简单，前期开发成本低，周期短，小型项目的首选。

2、开发效率高，模块之间交互采用本地方法调用。

3、容易部署，运维成本小，直接打包为一个完整的包，拷贝到web容器的某个目录下即可运行。

4、容易测试：IDE都是为开发单个应用设计的、容易测试——在本地就可以启动完整的系统。

缺点：

1、全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。

2、版本迭代速度逐渐变慢，修改一个地方就要将整个应用全部编译、部署、启动，开发及测试周期过长。

3、无法按需伸缩，通过集群的方式来实现水平扩展，无法针对某业务按需伸缩。

### 垂直架构（分布式架构）

针对单体架构的不足，为了适应大型项目的开发需求，许多公司将一个单体系统按业务垂直拆分为若干系统，系统之间通过网络交互来完成用户的业务处理，每个系统可分布式部署，这种架构称为分布式架构。

![20191126182758447](E:\STS+Maven构建SSM项目\20191126182758447.png)


特点：

1、按业务垂直拆分成一个一个的单体系统，此架构也称为垂直架构。

2、系统与系统之间的存在数据冗余，耦合性较大，如上图中三个项目都存在客户信息。

3、系统之间的接口多为实现数据同步，如上图中三个项目要同步客户信息。

优点：

1、通过垂直拆分，每个子系统变成小型系统，功能简单，前期开发成本低，周期短。

2、每个子系统可按需伸缩。

3、每个子系统可采用不同的技术。

缺点：

1、子系统之间存在数据冗余、功能冗余，耦合性高。

2、按需伸缩粒度不够，对同一个子系统中的不同的业务无法实现，比如订单管理和用户管理。

### SOA架构

SOA是一种面向服务的架构，基于分布式架构，它将不同业务功能按服务进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。

![20191126182836218](E:\STS+Maven构建SSM项目\20191126182836218.png)

特点：

1、基于SOA的架构思想，将重复公用的功能抽取为组件，以服务的方式向各各系统提供服务。

2、各各系统与服务之间采用webservice、rpc等方式进行通信。

3、ESB企业服务总线作为系统与服务之间通信的桥梁。

优点：

1、将重复的功能抽取为服务，提高开发效率，提高系统的可重用性、可维护性。

2、可以针对不同服务的特点按需伸缩。

3、采用ESB减少系统中的接口耦合。

缺点：

1、系统与服务的界限模糊，会导致抽取的服务的粒度过大，系统与服务之间耦合性高。

2、虽然使用了ESB，但是服务的接口协议不固定，种类繁多，不利于系统维护。

### 微服务架构

基于SOA架构的思想，为了满足移动互联网对大型项目及多客户端的需求，对服务层进行细粒度的拆分，所拆分的每个服务只完成某个特定的业务功能，比如订单服务只实现订单相关的业务，用户服务实现用户管理相关的业务等等，服务的粒度很小，所以称为微服务架构。

![20191126182905413](E:\STS+Maven构建SSM项目\20191126182905413.png)

特点：

1、服务层按业务拆分为一个一个的微服务。

2、微服务的职责单一。

3、微服务之间采用RESTful、RPC等轻量级协议传输。

4、有利于采用前后端分离架构。

优点：

1、服务拆分粒度更细，有利于资源重复利用，提高开发效率。

2、可以更加精准的制定每个服务的优化方案，按需伸缩。

3、适用于互联网时代，产品迭代周期更短。

缺点：

1、开发的复杂性增加，因为一个业务流程需要多个微服务通过网络交互来完成。

2、微服务过多，服务治理成本高，不利于系统维护。







## 传输方式

### RMI

​		Java RMI 指的是远程方法调用 (Remote MethodInvocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口。RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，但是客户端程序依赖这个IP和端口。这也是RMI的局限性之一。这个问题有两种解决途径：一是通过DNS来解决，二是通过封装将IP暴露到程序代码之外。RMI的局限性之二是RMI是Java语言的远程调用，两端的程序语言必须是Java实现，对于不同语言间的通讯可以考虑用WebService或者公用对象请求代理体系（CORBA）来实现。

使用代表：EJB

### RPC

​		RPC（Remote ProcedureCall Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

### JMS

​		Java 消息服务 (Java Messaging Service, JMS ) 是一种允许应用程序创建、发送、接受和读取消息的Java API 。JMS 在其中扮演的角色与JDBC 很相似，正如JDBC 提供了一套用于访问各种不同关系数据库的公共API，JMS 也提供了独立于特定厂商的企业消息系统访问方式。使用JMS 的应用程序被称为JMS 客户端，处理消息路由与传递的消息系统被称为JMS Provider，而JMS 应用则是由多个JMS 客户端和一个JMS Provider 构成的业务系统。发送消息的JMS 客户端被称为生产者（producer），而接收消息的JMS 客户端则被称为消费者(consumer)。同一JMS 客户端既可以是生产者也可以是消费者。JMS 的编程过程很简单，概括为：应用程序A 发送一条消息到消息服务器（也就是JMS Provider）的某个目得地(Destination)，然后消息服务器把消息转发给应用程序B。因为应用程序A 和应用程序B 没有直接的代码关连，所以两者实现了解偶。



### RMI和RPC

1. 返回值上：

   RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型。而 RPC 不支持对象的概念，传送到 RPC 服务的消息由外部数据表示 (ExternalData Representation,XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， RPC 不允许传递对象。可以说 RMI 是面向对象方式的 JavaRPC 。

2. 通信语言

​	  RMI：仅支持Java语言

​	  RPC：可以跨语言访问

3. 错误处理

​	  不支持对象，无法在编译器检查错误，只能在运行期检查。

4. 方法调用    

   在方法调用上，RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。在RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向RPC服务器表明，被请求的方法在为“classname”的类中，名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。

### RMI和JMS

1. 传输方式上

​    JMS 与 RMI 的区别在于，采用 JMS 服务，对象是在物理上被异步从网络的某个 JVM 上直接移动到另一个 JVM 上。

​    RMI 对象是绑定在本地 JVM 中，只有函数参数和返回值是通过网络传送的。

2. 方法调用上

​	RMI一般都是同步的，也就是说，当client调用Server的一个方法的时候，需要等到对方的返回，才能继续执行client端，这个过程调用本地方法感觉上是一样的，这也是RMI的一个特点。

​    JMS 一般只是一个点发出一个Message到Message Server,发出之后一般不会关心谁用了这个message。一般RMI的应用是紧耦合，JMS的应用相对来说是松散耦合应用。









## RPC

​		大型互联网公司中，公司的系统都由成千上万大大小小的服务组成，各服务部署在不同的机器上，由不同的团队负责。

这时就会遇到两个问题：

1. 要搭建一个新服务，免不了需要依赖他人的服务，而现在他人的服务都在远端，怎么调用？
2. 其它团队要使用我们的新服务，我们的服务该怎么发布以便他人调用？下文将对这两个问题展开探讨。

 

### 如何调用他人的远程服务？

由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。

如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行helloWorldService.sayHello("test")时，实质上调用的是远端的服务。这种方式其实就是RPC（Remote Procedure Call Protocol），在各大互联网公司中被广泛使用，如阿里巴巴的hsf、dubbo（开源）、Facebook的thrift（开源）、Google grpc（开源）、Twitter的finagle（开源）等。

要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：

![img](http://static.oschina.net/uploads/space/2016/0714/102634_AAIe_2243330.png)

1. 服务消费方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

### 怎么做到透明化远程服务调用？

怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：

1. jdk 动态代理
2. 字节码生成

尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。





## RMI

定义
RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。

Java RMI：Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。

远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。

方法调用从客户对象经占位程序（Stub)、远程引用层(Remote Reference Layer)和传输层（Transport Layer）向下，传递给主机，然后再次经传 输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。 占位程序扮演着远程服务器对象的代理的角色，使该对象可被客户激活。 远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。服务器端的骨干网完成对服务器对象实际的方法调用，并获取返回值。返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，占位程序获得返回值。 
要完成以上步骤需要有以下几个步骤： 
1、 生成一个远程接口 
2、 实现远程对象(服务器端程序)
3、 生成占位程序和骨干网(服务器端程序)
4、 编写服务器程序 
5、 编写客户程序 
6、 注册远程对象 
7、 启动远程对象  

简单实例：

​	远程接口创建：	

```
public interface IHello extends Remote{
	publiv String sayHello(String name) throws RemoteException;
}
```

​	远程接口实现类：

```
public class HelloImpl extends UnicastRemoteObject implements IHello{
	protected HelloImpl() throws remoteException{
		super();
	}
	private String sayHello(String name) throws RemoteException{
		return "Hello "+name;
	}
}
```

​	服务端

```
public class HelloServer{
	public static void main(String[] args){
		try{
			IHello hello=new HelloImpl();
			LocateRegistry.createRegistry(9527);
			java.rmi.Naming.rebind("rmi://localhost:9527/hello",hello);
			Syste.out.print("fine");
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
```

​	客户端

```
public class Test{
	public static void main(String[] args){
		try{
			IHello hello=(IHello)Naming.lookup("rmi://localhost:9527/hello");
			System.out.print(hello.sayHello("test"));
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
```









## 消息服务JMS

消息服务指的是两个应用程序之间进行异步通信的API，它为标准消息协议和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持应用程序开发。在Java中，当两个应用程序使用JMS进行通信时，它们之间并不是直接相连的，而是通过一个共同的消息收发服务连接起来，可以达到解耦的效果。

1. 简介

JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM-分布式系统的集成）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。

2. 体系架构

JMS由以下元素组成：

| JMS提供者 | 连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。 |
| --------- | ------------------------------------------------------------ |
| JMS客户   | 生产或消费基于消息的Java的应用程序或对象。                   |
| JMS生产者 | 创建并发送消息的JMS客户。                                    |
| JMS消费者 | 接收消息的JMS客户。                                          |
| JMS消息   | 包括可以在JMS客户之间传递的数据的对象。                      |
| JMS队列   | 一个容纳那些被发送的等待阅读的消息的区域。与队列名字所暗示的意思不同，消息的接受顺序并不一定要与消息的发送顺序相同。一旦一个消息被阅读，该消息将被从队列中移走。 |
| JMS主题   | 一种支持发送消息给多个订阅者的机制。                         |

3. JMS对象模型

![img](https://images2018.cnblogs.com/blog/1182616/201805/1182616-20180528082100248-989741849.png)

| **ConnectionFactory** | 创建Connection对象的工厂，针对两种不同的JMS消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。 |
| --------------------- | ------------------------------------------------------------ |
| **Connection**        | Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。 |
| **Session**           | Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。 |
| **MessageProducer**   | 消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。 |
| **MessageConsumer**   | 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。 |
| **Destination**       | Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。 |

4. JMS消息模型

在JMS标准中，有两种消息模型PTP（Point to Point）,Publish/Subscribe(Pub/Sub)。

5. PTP模式-点对点消息传送模型

在点对点消息传送模型中，应用程序由消息队列，发送者，接收者组成。每一个消息发送给一个特殊的消息队列，该队列保存了所有发送给它的消息(除了被接收者消费掉的和过期的消息)。

![img](https://images2018.cnblogs.com/blog/1182616/201805/1182616-20180528082100568-1791719539.gif)

PTP的特点

1，每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)。

2，发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。

3，接收者在成功接收消息之后需向队列发送确认收到通知（acknowledgement）。

6. Pub/Sub-发布/订阅消息传递模型

在发布/订阅消息模型中，发布者发布一个消息，该消息通过topic传递给所有的客户端。在这种模型中，发布者和订阅者彼此不知道对方，是匿名的且可以动态发布和订阅topic。

在发布/订阅消息模型中，目的地被称为主题（topic），topic主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。

![img](https://images2018.cnblogs.com/blog/1182616/201805/1182616-20180528082100808-945786782.gif)

Pub/Sub特点

1，每个消息可以有多个消费者。

2，发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个或多个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。

3，为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。

7. 接收消息

在JMS中，消息的接收可以使用以下两种方式：

| 同步 | 使用同步方式接收消息的话，消息订阅者调用receive()方法。在receive()中，消息未到达或在到达指定时间之前，方法会阻塞，直到消息可用。 |
| ---- | ------------------------------------------------------------ |
| 异步 | 使用异步方式接收消息的话，消息订阅者需注册一个消息监听者，类似于事件监听器，只要消息到达，JMS服务提供者会通过调用监听器的onMessage()递送消息。 |

8. JMS消息结构（Message）

Message主要由三部分组成，分别是Header，Properties，Body， 详细如下：

| Header     | 消息头，所有类型的这部分格式都是一样的                       |
| ---------- | ------------------------------------------------------------ |
| Properties | 属性，按类型可以分为应用设置的属性，标准属性和消息中间件定义的属性 |
| Body       | 消息正文，指我们具体需要消息传输的内容。                     |

9. 使用场景：
   		1）跨平台 
      		2）多语言 
      		3）多项目
      		4）解耦
      		5）分布式事务

   ​		6）流量控制
   ​		7）最终一致性
   ​		8）RPC调用
   ​			上下游对接，数据源变动->通知下属

10. JMS类似于JDBC，只提供传输的接口并不提供具体实现，其主要提供者：Apache ActiveMQ、RabbitMQ、Kafka、Notify、MetaQ、RocketMQ



## ActiveMQ

特点：
			1.支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议

​			2.支持许多高级功能，如消息组，虚拟目标，通配符和复合目标

​			3.完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息

​			4.Spring支持，ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置

​			5.支持在流行的J2EE服务器（如TomEE，Geronimo，JBoss，GlassFish和WebLogic）中进行测试

​			6.使用JDBC和高性能日志支持非常快速的持久化

启动：

​	双击bin目录下的win64中的activemq.bat,启动后访问路径http://127.0.0.1:8161/

面板：	
		Name：队列名称。
		Number Of Pending Messages：等待消费的消息个数。
		Number Of Consumers：当前连接的消费者数目
		Messages Enqueued：进入队列的消息总个数，包括出队列的和待消费的，这个数量只增不减。
		Messages Dequeued：已经消费的消息数量。





## Springboot整合ActiveMQ

### 点对点模式

1. pom.xml配置

   ```
   		<!-- 整合消息队列ActiveMQ -->
   		<dependency>  
               <groupId>org.springframework.boot</groupId>  
               <artifactId>spring-boot-starter-activemq</artifactId>  
           </dependency>  
           
           <!-- 如果配置线程池则加入 -->
           <dependency>
               <groupId>org.messaginghub</groupId>
               <artifactId>pooled-jms</artifactId>
           </dependency>
   ```

2. application.propertis配置

   ```
   		spring.activemq.broker-url=tcp://127.0.0.1:61616
   
   		#集群配置
   		#spring.activemq.broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)
   
   		spring.activemq.user=admin
   		spring.activemq.password=admin
   		#下列配置要增加依赖
   		spring.activemq.pool.enabled=true
   		spring.activemq.pool.max-connections=100
   
   ```

3. 创建默认的queue对象

4. 编写service层方便用于发送消息至消息队列

5. controller编写方法用于发送消息

6. 扫描JMS

7. 编写消费者进行消费

