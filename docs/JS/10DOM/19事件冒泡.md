#### 事件的冒泡

- 指事件的向上传导
- 当元素上的某个事件被触发后,其祖先元素上的相同事件也会同时被触发
- 冒泡简化了代码的编写
- 不希望事件冒泡时,可以通过事件对象来取消冒泡

```js
<body>
    <div class="box1">
        <div class="box2">
            <div class="box3"></div>
        </div>
    </div>
</body>
<script>

    const box1 = document.querySelector('.box1')
    const box2 = document.querySelector('.box2')
    const box3 = document.querySelector('.box3')
    box1.addEventListener("click",function (){alert(1)})
    box2.addEventListener("click",function (){alert(2)})
    box3.addEventListener("click",function (){alert(3)})
</script>
```

### 取消传导

```js
    box3.addEventListener("click",function (){
    alert(3)
    event.stopPropagation()//取消传导
    }
```

> ### 在事件响应函数中event.target表示触发事件的对象,即点击box1指向box1,点击box2指向box2
>
> ### this则指绑定事件的对象,点击box1,指向box1,点击box2,指向box2

### 完全取消传导

###### 可以使用 `event.stopImmediatePropagation()` 方法。这个方法不仅会阻止事件冒泡，还会阻止同一元素上绑定的后续事件处理函数的执行。

```js
box2.addEventListener("mousemove", function (event) {
  event.stopImmediatePropagation();
});
```

#### 事件的冒泡与元素的样式无关,和结构有关

###### 移动小球实验

```js
    <style>
        .box1{
            width: 100px;
            height: 100px;
            background-color: #2f5e8b;
            border-radius: 50%;
            position: absolute;
        }
        .box2{
            width: 300px;
            height: 300px;
            background-color: #27c6db;
        }
    </style>
</head>
<body>
    <div class="box1"></div>
    <div class="box2"></div>
</body>
<script>
    const box1 = document.getElementsByClassName('box1')[0]
    const box2 = document.getElementsByClassName('box2')[0]
    document.addEventListener("mousemove",function (event){
        box1.style.left = event.x+"px"
        box1.style.top = event.y+"px"
    })
    box2.addEventListener("mousemove",function (event){
        event.stopImmediatePropagation();
    })
</script>
```

